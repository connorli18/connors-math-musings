

\section{Relevant Resources}
\begin{itemize}
    \item \textbf{Relevant Lab:} Internet Real-Time Lab (IRT), Columbia University Department of Computer Science
    \item \textbf{Research Advisors:} Luoyao Hao, Henning Schulzrinne
    \item \textbf{Author Emails:} csl2192@columbia.edu, hk3187@columbia.edu
    \item \textbf{Video Demonstration:} Click \href{https://youtu.be/laNO6OkpahU}{here} for my beautiful voice
\end{itemize}


\pagebreak
\section{IoT Background Information}
\subsection{Modern, Escalating Cyber Threats}
In the age of the internet, the economic impact of cybercrime continues to surge at an alarming rate. It is projected that in 2021, cybercrime inflicted global damages totaling \$6 trillion USD. This stark number is a testament to the increasing sophistication and frequency of cyberattacks faced by individuals, corporations, and governments worldwide. The economic trajectory of cybercrime costs reveals an even more daunting future, with projected growth rate of 15 percent YOY, reaching a monumental \$10.5 trillion USD annually by 2025. \\
\\
In response to the rising tide of cyber threats, global spending on cybersecurity products is also seeing significant growth. Over the five-year period from 2021 to 2025, cumulative investment in cyber defense is estimated to have exceeded \$1 trillion USD. This substantial financial commitment reflects the critical need for advanced protective measures and the escalating demand within the constantly evolving space.
$$
\includegraphics[width=12cm]{SPENDING2025.png}
$$
Keeping pace with this dramatic increase in cybercrime is the rapid expansion of internet connectivity, with around one million new users going online each day. By 2023, the number of networked devices globally is predicted to triple the human population, presenting an unprecedented expansion in potential vulnerabilities. Furthermore, by 2022, the planet will host 1 trillion networked sensors, escalating to 45 trillion within a matter of two decades. This is also matched by exponential growth in IP traffic, which soared to an annual run rate of 2.3 zettabytes in 2020 from 870.3 exabytes in 2015. \\
\\
Given the vast expansion of networked devices, there is a pressing need for innovative network protection strategies that can adapt to and secure an increasingly complex and vulnerable digital landscape. 
\subsection{Introduction to Firewalls}
One example of these innovative strategies is the development of firewalls. In short, firewalls are indispensable for safeguarding digital assets and serve as the first line of defense in a network's security framework. They operate at the network's edge, scrutinizing incoming and outgoing traffic to prevent unauthorized access and block cyber threats. By enforcing security policies and filtering traffic based on predefined rules, firewalls reinforce the security perimeter, protecting sensitive data and networked systems from exploitation by malicious actors. As the number and complexity of cyber threats continue to grow, the role of firewalls evolves to offer more sophisticated, adaptive solutions that can dynamically respond to new vulnerabilities and attacks.\\
\\
The modern implementations often utilize stateful inspection techniques. This method tracks the state of active connections and makes decisions about which network packets to allow through based on state, port, and protocol. Furthermore, firewalls can analyze the contents of the data packets, header information, and other aspects of transmissions which allows for more granular security decisions, effectively identifying and blocking packets with malicious data. Additionally, firewalls can be integrated with other security frameworks, creating a comprehensive security infrastructure that adapts to the constantly emerging threats.
\subsection{Diverse Firewall Architectures}
While this paper is principally centered on the P4 Firewall architecture at the switch level, it is essential to also have a robust grasp of other firewall types. This section delves into the modern implementations of diverse firewall technologies. Each variant, from network layer firewalls to application layer firewalls, serves a distinct role in a comprehensive multi-layered defense strategy, effectively enhancing the network's ability to counteract evolving cyber threats.
\begin{itemize}
    \item \textbf{Session Layer Firewall:} These firewalls, also known as Circuit-Level Gateways, enhance network security by focusing on the integrity of session initiations. They employ robust session tracking mechanisms to verify the authenticity and authorization of network connections, significantly bolstering defenses against session hijacking and other protocol-specific attacks. By monitoring the state of network connections, these firewalls detect and prevent unauthorized access, ensuring the security of communication channels across the network.
    \item \textbf{Application Layer Firewall:} These firewalls, also know as Proxy Firewalls, serve as critical intermediaries between end-users and the Internet. These firewalls intercept all inbound and outbound messages, conducting deep packet inspections to scrutinize both content and headers. Operating at the application level, they enforce rigorous user-level controls and perform extensive content filtering, thus providing superior security. Their ability to mask internal network addresses effectively shields against direct external attacks, enhancing overall network security.
    \item \textbf{Network Layer Firewalls:} These firewalls operate at the IP level, analyzing and filtering network traffic based on IP addresses and port numbers. These systems enforce detailed router-protocol policies that manage intricate data flows, ensuring only authorized traffic accesses the network. Utilizing advanced packet filtering technologies, these firewalls inspect each packet's header for source and destination information, playing a pivotal role in preemptively blocking potentially harmful communications and protecting network integrity.
\end{itemize}
At the forefront of firewall technology, P4-based Packet Filtering operates within the Network (IP) layer, leveraging the programmable nature of the P4 language to dynamically customize behaviors. This advanced capability allows firewalls to inspect, modify, and make real-time decisions on each packet, using complex match-action rules tailored to specific network needs. The inherent flexibility of P4-based systems enables the development of precise, adaptable security policies that can be continually refined.
\subsection{Advantages of P4 Firewalls}
\subsubsection{Programmability}
P4-based firewalls excel in their programmability, allowing network engineers to implement and modify custom firewall rules and policies directly within the data plane. This is achieved through the P4 language, which abstracts hardware complexities and provides a high level of control over the packet-processing logic. This programmability extends beyond simple firewall configurations to include sophisticated network functions such as traffic monitoring, load balancing, and more, all tailored to specific network requirements without the need for new hardware deployments.
\subsubsection{High-Speed Performance}
The high-speed performance of P4-based firewalls is unparalleled due to their direct implementation on the network hardware level. By processing packets at the hardware level, P4 firewalls can achieve linear-rate speeds, which is essential for maintaining network performance during high-volume traffic periods. This capability ensures that security measures do not become a bottleneck, thereby preserving the integrity and responsiveness of the network under all conditions.
\subsubsection{Advanced Scalability}
The scalability of P4-based firewalls provides a key advantage. Because these firewalls are deeply integrated into the network hardware and managed through flexible, programmable interfaces, they can effortlessly scale to handle increasing amounts of network traffic and more complex security protocols. The ability to dynamically adjust and scale security rules without degrading performance allows organizations to respond quickly to new threats and changes in network traffic patterns, maintaining robust security without compromising on performance.


\section{Basics of P4 and P4Runtime}
\subsection{Introduction to P4}
Developed by Professor Nick McKeown from Stanford University in 2013, P4 quickly became integral to software-defined networking (SDN). Its development underscored a shift from fixed-function network devices to more versatile, software-driven technologies, paving the way for innovative network management and operation solutions.\\
\\
The P4 language is specifically designed for programmable network devices, enabling precise control over how network protocols are processed and handled. Its strength lies in its protocol independence, meaning it does not inherently support standard protocols like IP or TCP. Instead, programmers define the necessary packet protocols directly in the P4 program, which are then interpreted by the target hardware.\\
\\
In traditional network switches, the hardware's functionality limits the data plane's capabilities. In contrast, P4 allows the data plane functions to be dynamically defined by the P4 program itself, enhancing flexibility and enabling the implementation of specific network functions tailored to unique requirements.\\
$$
\includegraphics[width=12cm]{standard_and_p4-defined_switches.png}
$$
In most papers, you will see P4 described as adopting a "top-down" approach for network device programming. Specifically, we see that P4 programs define the desired network functionalities at a high level. These programs are then compiled and injected into the network device, requiring the hardware to support programmability. This method contrasts with the traditional "bottom-up" approach where the capabilities are defined by the hardware's fixed functions, limiting flexibility.
$$
\includegraphics[width=9cm]{bottom-up.png}
$$
For a more comprehensive understanding of the P4 programming language and to access hands-on tutorials, please visit the dedicated GitHub repository. This site offers a wealth of resources, including step-by-step guides, example projects, and community support, which were invaluable for our understanding of P4. Explore these resources by following the link provided \href{https://github.com/p4lang/tutorials}{here}.
\subsection{Introduction to P4Runtime}
It is crucial to distinguish between P4 Runtime and the P4 language, as they serve different but complementary purposes. As mentioned above, the P4 language is primarily used to define the processing behavior of packets within a switch, detailing the operations performed on packet fields and the sequence of these operations. However, P4 Runtime is an API that facilitates the actual control of these devices once their behavior has been defined using the P4 language. \\
$$
\includegraphics[width=12cm]{p4runtime.png}
$$
With its development, P4 Runtime marked a groundbreaking new approach to managing the forwarding planes of network devices such as switches, routers, and firewalls. This protocol is unique because it allows control over any type of forwarding plane. The architecture of P4 Runtime is consistent across different device types, supporting a broad range of customizable protocols and features with the ability to manage a diverse array of network devices effectively (a plus for scalability of network systems). \\
\\
Historically, network devices were managed through proprietary APIs that were fixed and closed. These APIs were designed specifically for certain chipsets and did not accommodate the dynamic addition of new features or protocols. Moreover, non-disclosure agreements and licensing constraints prevented these APIs from being shared or used to manage devices from different manufacturers. This limitation hindered innovation and flexibility in network management. P4 Runtime addresses these issues by providing a standardized and open API that evolves dynamically as new features are introduced to the network device, without requiring a restart or reboot of the control plane.\\
\\
P4 Runtime's flexibility stems from its integration with the P4 programming language. Network developers can define device behavior using P4, and then use P4 Runtime to manage these behaviors dynamically. For instance, a developer might specify an IPv4 longest-prefix-match (LPM) table within a P4 program. The P4 compiler then automatically generates a schema based on this specification, which P4 Runtime uses to manage the table entries at runtime. This capability is not restricted to predefined functions; developers can extend or modify the P4 program to introduce new functionalities, like IPv6 prefix tables or custom rules for network traffic.
\subsection{P4 Switch Architecture}
Each endpoints are connected by P4's virtual switches that receives and forwards the packets according to the programmed match-action table. Once a switch receives a packet from its input ports, it extracts the fields from the header which describes the permitted sequences of headers within received packets, how to identify those header sequences, and the headers and fields to extract from packets.\\
\\
In detail, to forward a packet in IPv4 forwarding, each switch will (i) update the source and destination MAC addresses, (ii) decrement the time-to-live (TTL) in the IP header, and (iii) forward the packet out the appropriate port. Each switch will maintain a match-action table which is updated by the control plane with some static rules. Each rule will map an IP address or other parts of header to the MAC address and output port for the next hop. When a rule matches a packet, its action such as forwarding or dropping is invoked with parameters supplied by the control plane as part of the rule. This rule can also be dynamically updated by P4 Runtime from the control plane. \\
\\
As shown in the diagram below, the design of virtual switches can be broken down into input channel, parser, ingress match-action, buffer, egress match-action, and output channel.
$$
\includegraphics[width=12cm]{switch_arch.png}
$$
\subsection{P4 Runtime API}
P4 is a language for programming the data plane of network devices. However, it lacks the flexibility of dynamically updating the match action table during the runtime. The P4Runtime API is a control plane specification for controlling the data plane elements in python which allows the developers to write controller applications for P4 devices or switches. \\
\\
The figure below shows the pipeline of how Runtime API plays a role in P4 runtime. Once P4 program is written with the basic topology of the network and basic match-action behavior, it gets compiled with P4 compiler. The compiled information is used to create data plane runtime simulation including the table and extern objects in data plane. Then, Runtime API is used to construct control plane scripts that dynamically updates the tables in the data plane.
$$
\includegraphics[width=12cm]{p4_runtime.png}
$$

\section{Packet Rate & Size Monitoring Solution for IoT Firewall Rules}
\subsection{Overview of Project}
The solution implemented within this section is designed to provide robust security measures directly at the switch level, effectively preventing malicious packet transmissions to targeted host IP addresses in a variety of scenarios. Specifically, this project is engineered in order to tailor to three core blocking functionalities, each used to intercept different types of network threats:
\begin{itemize}
    \item \underline{Packet Size Filtering}: This functionality blocks packets based on their size. It is designed to detect and prevent oversized or undersized packets which often signify malicious intent, such as buffer overflow attacks or malformed packet exploits.
    \item \underline{Arbitrary Host Blocking}: This feature allows network administrators to specify one or more host IP addresses that are to be completely blocked from sending packets within the network. This is particularly useful for isolating and mitigating threats from known malicious sources or compromised systems.
    \item \underline{Packet Rate Limiting}: To combat denial-of-service (DoS) attacks, our firewall includes a packet rate limiting feature. This function monitors the rate of incoming packets and automatically throttles or blocks traffic that exceeds predefined thresholds, ensuring that network resources are not overwhelmed by malicious traffic bursts.
\end{itemize}
In each section, you will see the logic behind the implementation at both the switch and controller level as well as instructions on how to test on a clean-state Linux machine. For more details, please also reference the GitHub repository linked in the relevant materials section. 
\subsection{Network Topology}
\subsubsection{Subnet Implementation}
Our project's network topology is designed to provide a robust and scalable structure for the deployment of our voice analysis tools. The network is primarily structured around three switches (\verb|s1, s2, s3|) and three hosts (\verb|h1, h2, h3|). Below, we provide an overview of the topology along with the configuration details of the hosts and the interconnections between the hosts and switches.\\
\\
Here is the JSON configuration that specifies the IP addresses, MAC addresses, and routing commands for each host, as well as the connections that define the network topology:
\begin{lstlisting}
    {
        "hosts": {
            "h1": {"ip": "10.0.1.1/24", "mac": "08:00:00:00:01:11",
                   "commands":["route add default gw 10.0.1.10 dev eth0",
                               "arp -i eth0 -s 10.0.1.10 08:00:00:00:01:00"]},
            "h2": {"ip": "10.0.2.2/24", "mac": "08:00:00:00:02:22",
                   "commands":["route add default gw 10.0.2.20 dev eth0",
                               "arp -i eth0 -s 10.0.2.20 08:00:00:00:02:00"]},
            "h3": {"ip": "10.0.3.3/24", "mac": "08:00:00:00:03:33",
                   "commands":["route add default gw 10.0.3.30 dev eth0",
                               "arp -i eth0 -s 10.0.3.30 08:00:00:00:03:00"]}
        },
        "switches": {
            "s1": {  },
            "s2": {  },
            "s3": {  }
        },
        "links": [
            ["h1", "s1-p1"], ["h2", "s2-p2"], ["h3", "s3-p3"],
            ["s1-p2", "s2-p1"], ["s1-p3", "s3-p1"], ["s2-p3", "s3-p2"]
        ]
    }
\end{lstlisting}
Below is the visual representation of this topology.
$$
\includegraphics[width=10cm]{pod-topo.png}
$$
\subsubsection{Testing: Starting the Mininet}
Start on a clean-state Linux machine, and navigate to the Virtual Machine. For more instructions on installing the virtual machine, please see the \href{https://github.com/p4lang/tutorials?tab=readme-ov-file#obtaining-required-software}{P4 Tutorials Repository}. Once you are in the Virtual machine,
\begin{enumerate}
    \item Enter the p$4$ user profile and open the terminal. Navigate to the tutorials $\rightarrow$ IoTFirewall folder, and \verb|make clean|.
    \item Next, use \verb|make| to create the mininet.
    \item In the mininet terminal, use \verb|xterm h1 h2 h3| to create terminals for the 3 host devices
    \item In a separate terminal (outside of the mininet), run \verb|sudo python3 controller.py| to start up your controller.
\end{enumerate}
Now, we can begin testing. The controller should show all three hosts connected.
\subsubsection{Testing: Sending Packets}
In order to first ensure that mininet is working, let's try to send/receive basic packets across the multiple host devices. To do this, simply follow these instructions within the terminals for the devices \verb|h1, h2, h3| created within the mininet:
\begin{enumerate}
    \item In the \verb|h2, h3| terminals, run \verb|sudo python3 receive.py|
    \item In the \verb|h1| terminal, run \verb|sudo python3 send.py h2/h3 'Arsenal will bottle the Premier League'|
\end{enumerate}
In the controller terminal, it should show that \verb|h1| is sending packets. On top of that, you should also see in the \verb|h1, h2, h3| terminals that packets are being sent recieved across the devices.
\subsection{Match-Action Table Changes}
Our current network leverages P4-based IPv4 forwarding, which routes packets based on destination IP addresses. To bolster security, our project requires the implementation of advanced IP blocking strategies: blocking traffic to and from specific destination and source IPs. This necessitates sophisticated modifications to the P4 match-action tables, enabling precise filtering of both incoming and outgoing packets based on IP criteria. 
\subsubsection{Dropping by Destination IP}
To implement destination IP-based blocking, we introduced modifications to the \verb|utils/p4runtime_lib/|\verb|switch.py| file, adding specialized functions that enable dynamic updates to the forwarding rules in the P4 Runtime's behavioral model (bmv2). One critical function, \verb|DeleteTableEntry|, is designed to remove existing table entries that dictate packet forwarding behaviors, replacing them with rules that instead drop packets to specific IP addresses:

\begin{lstlisting}
    def DeleteTableEntry(self, table_entry, dry_run=False):
        request = p4runtime_pb2.WriteRequest()
        request.device_id = self.device_id
        request.election_id.low = 1
        update = request.updates.add()
        update.type = p4runtime_pb2.Update.DELETE
        update.entity.table_entry.CopyFrom(table_entry)
        if dry_run:
            print("P4Runtime Delete: ", request)
        else:
            self.client_stub.Write(request)
\end{lstlisting}
In the context of our P4 program (\verb|basic.p4|), the \verb|ipv4_lpm| table plays a pivotal role in this mechanism. Initially configured for longest prefix matching (LPM) to route packets based on destination IP addresses, we have enhanced this table to include an action that enables packet dropping:
\begin{lstlisting}
    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = drop();
    }
\end{lstlisting}
The blocking functionality is enacted through a controller mechanism that first deletes the existing forwarding rule and then builds/writes new table entries. These entries explicitly instruct the switch to drop packets matching the designated destination IP address, effectively nullifying any previous forwarding rules:
\begin{lstlisting}
    table_entry = p4info_helper.buildTableEntry(
        table_name="MyIngress.ipv4_lpm",
        match_fields={
            "hdr.ipv4.dstAddr": (dst_ip_addr, 32)
        },
        action_name="MyIngress.ipv4_forward",
        action_params={
            "dstAddr": dst_eth_addr,
            "port": port,
            "dst_id": dst_id
        }
    )
    ingress_sw.DeleteTableEntry(table_entry, False)
    
    # Change to drop func
    table_entry = p4info_helper.buildTableEntry(
        table_name="MyIngress.ipv4_lpm",
        match_fields={
            "hdr.ipv4.dstAddr": (dst_ip_addr, 32)
        },
        action_name="MyIngress.drop"
    )
    ingress_sw.WriteTableEntry(table_entry)
\end{lstlisting}
\subsubsection{Dropping by Source IP}
In conventional P4 applications, IP forwarding primarily utilizes destination IP addresses (\verb|dst_addr|). To enhance network security controls, our project introduces a novel mechanism to block traffic based on source IP addresses (\verb|src_addr|). This addition necessitates the creation of a new table within our P4 program specifically for managing rules associated with source addresses, which differs fundamentally from the existing destination-based approaches.\\
\\
To facilitate this new functionality, we first define a metadata structure to track whether a packet should be dropped. The metadata includes a bit (\verb|src_lpm_hit|) which is set to $1$ when a packet meets the drop criteria.
\begin{lstlisting}
    struct metadata {
        bit<1> src_lpm_hit;
        /* other metadata fields... */
    }
    
    action drop() {
        mark_to_drop(standard_metadata);
        meta.src_lpm_hit = 1;
    }
\end{lstlisting}
Now, we define a new table, \verb|ipv4_src_lpm|, which utilizes longest prefix matching (LPM) on the source IP address and includes actions to handle different packet scenarios. The default action of this table is to set the \verb|src_lpm_hit| bit to 0, indicating that the packet has not been marked for dropping under normal circumstances.
\begin{lstlisting}
    table ipv4_src_lpm {
        key = {
            hdr.ipv4.srcAddr: lpm;
        }
        actions = {
            NoAction;
            drop;
            set_src_lpm_hit_to_zero;
        }
        size = 1024;
        default_action = set_src_lpm_hit_to_zero();
    }
\end{lstlisting}
Within the MyIngress control block, the source IP blocking table is applied prior to any destination-based forwarding decisions. This sequential application ensures that packets are first checked against the source IP blocking rules. If a packet is not marked as dropped (\verb|src_lpm_hit == 0|), it is then evaluated by the destination IP forwarding rules.
\begin{lstlisting}
    apply {
        if (hdr.ipv4.isValid() && !hdr.myTunnel.isValid()) {
            ipv4_src_lpm.apply();  // Apply source IP blocking rules
            if (meta.src_lpm_hit == 0) {
                ipv4_lpm.apply();  // Proceed with destination IP forwarding
            }
            // ---- Rest of the processing logic ----
        }
    }
\end{lstlisting}
To populate and modify the \verb|ipv4_src_lpm| table at runtime, we define a function blockTableEntry2, which interfaces with the P4 Runtime to dynamically insert drop rules based on source IP addresses. This will be used dynamically in many of the functionalities we want to implement at the controller level.
\begin{lstlisting}
    def blockTableEntry2(p4info_helper, ingress_sw, src_ip_addr):
        table_entry = p4info_helper.buildTableEntry(
            table_name="MyIngress.ipv4_src_lpm",
            match_fields={
                "hdr.ipv4.srcAddr": (src_ip_addr, 32)
            },
            action_name="MyIngress.drop"
        )
        ingress_sw.WriteTableEntry(table_entry);
\end{lstlisting}
The diagram below illustrates the integration of this mechanism within our network topology, outlining the flow of packet processing through the newly defined tables for \verb|src_addr| blocking.
$$
\includegraphics[width=13cm]{blocker-demo (1).png}
$$
\subsection{Packet Size Firewall}
\subsubsection{Implementation Notes}
The first part of the project implements a proactive security measure by integrating a packet-size based firewall rule within our P4-enabled switch. This rule is designed to identify and mitigate potential attacks characterized by unusually large packet sizes, which are often indicative of malicious activities such as buffer overflow attacks or other denial-of-service (DoS) strategies.\\
\\
The firewall rule is defined using a constant that specifies the maximum allowable packet size, set to $1024$ bytes ($1 \ll 10$). This threshold is chosen based on typical network traffic patterns and the specific security requirements of our infrastructure.
\begin{lstlisting}
    // Defined outside of Ingress
    const bit<16> MAX_PACKET_SIZE = 1 << 10;
\end{lstlisting}
During the packet processing phase within the Ingress control block, each incoming packet's total length is checked against this maximum value. If a packet's size exceeds the defined maximum, it is immediately marked for dropping. This decision is enforced by invoking the \verb|mark_to_drop| action on the \verb|standard_metadata|, effectively filtering out oversized packets before they can traverse the network.
\begin{lstlisting}
    // Defined inside Ingress Processing
    if (hdr.ipv4.totalLen > MAX_PACKET_SIZE) {
        mark_to_drop(standard_metadata);
    }
\end{lstlisting}
It is important to note that this implementation is done entirely at the level of the switch, with no involvement from the controller.
\subsubsection{Testing Instructions}
To show this blocking functionality works, let's assume that you've set up the mininet console and have terminals for \verb|h1, h2, h3|.
\begin{enumerate}
    \item Once you've completed the above, in the terminal for \verb|h2, h3|, run \verb|sudo python3 receive.py|
    \item If you want to test that regular packets are going through, run \verb|sudo python3 send.py h2/h3 'I love P4'| in the terminal for \verb|h1|
    \item Now, to show that packets are being dropped, run \verb|sudo python3 large-send.py h2/h3| which will send a packet of size $\geq 2^{10} = 1024$. If the functionality works, you should see that no packets are being received by \verb|h2, h3|.
    \item (Optional) Run Step 2 again to show that regular size packets are still being sent through!
\end{enumerate}
\subsection{Identified Threat Firewall}
\subsubsection{Implementation Notes}
The system is designed around a control plane that communicates with network devices via UDP sockets. This method allows for rapid signaling between hosts and the controller, facilitating immediate security actions based on detected threats.
\begin{lstlisting}
    // UDP send: block.py --> controller.py
    UDPClientSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
    UDPClientSocket.sendto(b'1', ("127.0.0.1", 20001))
    
    // Listening on the socket
    UDPServerSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
    UDPServerSocket.bind(("127.0.0.1", 20001))
    while True:
        bytesAddressPair = UDPServerSocket.recvfrom(1024)
\end{lstlisting}
In a scenario where host \verb|h2| is identified as a source of malicious activity, the system allows for the immediate disconnection and blocking of this host from switch \verb|s1|. The blocking operation is executed by sending a UDP message from the blocking script (\verb|block.py|) on \verb|h2| to the controller. Upon receiving this signal, the controller executes table rewriting functions defined in the P4 program, which instruct switch \verb|s1| to drop all incoming packets from \verb|h2|.\\
\\
Below is a diagram that accompanies the description above, illustrating the communication flow and interaction between the host, the controller, and the switch.
$$
\includegraphics[width=10cm]{Screenshot 2024-05-02 at 2.41.48â€¯PM.png}
$$
\subsubsection{Testing Instructions}
To show how this functionality works, let's assume that you've set up the mininet console, \verb|controller.py|, and have terminals for \verb|h1, h2, h3|. 
\begin{enumerate}
    \item Once you've completed the above, in the terminal of \verb|h1, h3|, run \verb|sudo python3 receive.py|
    \item We want to see that regular packets are going through to the host devices. So, run \verb|sudo python3 send.py h1/h3 'I love P4'| in the terminal for \verb|h2|
    \item In a new terminal outside of the mininet, run \verb|sudo python3 block.py h2|. Now, \verb|h2| should be blocked at \verb|s1|. In the original \verb|controller.py| terminal, you should see that \verb|s2| is disconnected.
    \item Finally, try sending packets through. In the \verb|h2| terminal, try running \verb|sudo python3 send.py h1/h3 'I love Arsenal'|. You should see that the controller and \verb|h2|-terminal are both registering sending packets, which are being received by \verb|h3| but not \verb|h1|.
\end{enumerate}
\subsection{Packet Rate Firewall}
\subsubsection{Implementation Notes}
The core of our packet-rate monitor is built around P4's native counters, which function analogously to arrays in general-purpose programming languages. For more information on counters, please visit this site \href{https://cornell-pl.github.io/cs6114/lecture07.html}{here}. \\
\\
In this implementation, we first introduce a counter, \verb|h_counter|, within the Ingress control block of the switch's P4 program. This counter is tasked with tracking both the packet and byte counts based on unique identifiers derived from IP addresses.
\begin{lstlisting}
    // Counter definition
    counter(MAX_ID, CounterType.packets_and_bytes) h_counter;
    
    // Ingress processing logic
    apply {
        if (hdr.ipv4.isValid() && !hdr.myTunnel.isValid()) {
            ipv4_lpm.apply();
            if (hdr.ipv4.flags[1:1] == 0) {
                bit<32> lastTwoParts = (bit<32>) (hdr.ipv4.srcAddr & 0x0000FFFF);
                h_counter.count(lastTwoParts);
            }
            if (hdr.ipv4.totalLen > MAX_PACKET_SIZE) {
                mark_to_drop(standard_metadata);
            }
        }
        if (hdr.myTunnel.isValid()) {
            myTunnel_exact.apply();
        }
    }
\end{lstlisting}
This segment tracks packets originating from non-tunneled IPv4 sources. The counter incrementally logs entries based on the last two octets of the source IP address, effectively segmenting count data per subnet. To access and manipulate these counters dynamically, we implemented a \verb|counterFinder| function within the controller environment. This function fetches real-time packet count data from specified indices, enabling on-the-fly traffic analysis.
\begin{lstlisting}
    def counterFinder(p4info_helper, sw, counter_name, index):
        try {
            for response in sw.ReadCounters(p4info_helper.get_counters_id(counter_name), index):
                for entity in response.entities:
                    counter = entity.counter_entry
                    return counter.data.packet_count
        } catch(Exception e) {
            print(f"Error when reading counter at index {index}: {e}")
        }
    }
\end{lstlisting}
The system employs a \verb|packetratetracker| function in the controller, which periodically reads the counter values to monitor the packet rate. If a significant deviation from the norm is detected, indicating potential malicious activity, an automated response is triggered to block the offending device. 
\begin{lstlisting}
    def packet_rate_tracker(p4info_helper, ingress_sw):
        """
        Monitors the packet rate from specific hosts and 
        blocks traffic if a threshold is exceeded.
        
        Args:
        p4info_helper: An instance of the P4Info helper utility.
        ingress_sw: The ingress switch instance where the monitoring is applied.
        """
        
        # <----- Network Topology Var Definitions Excluded ------->
        
        # Initialize tracker for previous packet count
        previous_count = 0
    
        # Continuous monitoring loop with a sleep interval of 5 seconds
        while True:
            sleep(5)
            ip = ip_tracks[ingress_sw.name]
            index = get_last_two_parts(ip)
    
            # Fetch the new packet count from the counter
            new_count = counterFinder(p4info_helper, ingress_sw, "MyIngress.h_counter", index)
    
            # Check if the change in count exceeds the threshold
            if abs(new_count - previous_count) >= 100:
                # Block the host if threshold is exceeded
                blockTableEntry2(p4info_helper, ingress_sw, block_switch_info)
            else:
                # Update the tracker and optionally print the current count
                previous_count = new_count
                # printCounter(p4info_helper, ingress_sw, "MyIngress.h_counter", index)
\end{lstlisting}
A diagram detailing the specifics behind the implementation is also included below.
$$
\includegraphics[width=10cm]{packet-rate-demo (3).png}
$$
In a practical scenario, consider host \verb|h1| exhibiting suspicious network behavior. The switch \verb|s1|, upon detecting an abnormal packet rate from \verb|h1|, is programmed to automatically inhibit further packet transmissions from this source. This preemptive action is designed to mitigate any possible damage from distributed denial-of-service (DDoS) attacks or other malicious disruptions. 
\subsubsection{Testing Instructions}
If you haven't restarted the mininet after the arbitrary blocking functionality, make sure to do that. If you are unsure of how to do this, reference the section called "Starting the Mininet".
\begin{enumerate}
    \item Once you've set up the subnet topology, in the \verb|h2| terminal, run \verb|sudo python3 receive.py|.
    \item We want to show that regular packets are allowed to be sent through. So, in \verb|h1| terminal, run \verb|sudo python3 send.py| \verb|h2 'Chelsea forever'|. 
    \item Now, we want to test the spam blocking functionality. In the \verb|h1| terminal, run \verb|sudo python3 spam-send.py h2 --duration| \verb|10 'i love p4'|. This is a program designed to spam send packets from \verb|h1| $\rightarrow$ \verb|h2|.
    \item In the \verb|controller.py| terminal, you should see that \verb|h1| is disconnected.
    \item To be sure, try sending a packet to \verb|h2| using \verb|sudo python3 send.py h2 'I love P4444'| in the \verb|h1 terminal|.
\end{enumerate}
\subsection{Future Direction of Project}
As our project continues to evolve, we aim to significantly enhance and expand the capabilities of our network security infrastructure. The following areas highlight our key focus for future developments:\\
\\
\textbf{Enhancing Existing Features:}
\begin{itemize}
    \item \underline{Scalability and Improvement of Blocking Features}: We plan to refine and scale our current blocking mechanisms to handle higher traffic volumes and more complex threat scenarios efficiently. This will include optimizing our P4 programs and control plane logic to ensure faster and more reliable response times.
    \item \underline{Integration with External Threat Intelligence}: As with Heeyun's project, we intend to incorporate external threat data into our blocking logic. This integration will allow us to dynamically adjust our security measures based on real-time threat analysis and intelligence, enhancing our ability to preemptively block identified threats.
    \item \underline{Dynamic Packet Rate Monitoring}: Future developments could involve improving our packet rate monitoring by enhancing the dynamic nature of our control plane's dictionary. This involves leveraging \verb|packet_in/packet_out| functionality to allow real-time updates and adjustments to our monitoring and blocking strategies based on observed network conditions.
    \item \underline{Adaptive Traffic Rate Controls}: Further developments will also focus on dynamically updating acceptable traffic rates. This will adapt to varying network conditions and usage patterns, ensuring optimal performance without compromising on security.
\end{itemize}
\textbf{Introducing New Features}:
\begin{itemize}
    \item \underline{Dynamic Firewall Rule Updates}: Testing and implementing dynamic rule updates will be a priority. This involves creating a more flexible and responsive firewall system that can adjust its rules without manual intervention, based on the network state and emerging threats.
    \item \underline{Deep Packet Inspection (DPI)}: Possibly implementing DPI to enhance our ability to detect and respond to sophisticated threats that require analysis beyond basic header information. DPI will allow for a more granular look at the packet content, enabling precise blocking of malicious traffic.
    \item \underline{Protocol-Specific Features}: Updates will include developing features targeted at specific protocols. This will address unique vulnerabilities and optimize security measures tailored to protocol-specific characteristics and risks.
\end{itemize}
These future directions are designed to not only enhance the robustness and efficiency of our network security measures but also to ensure that our infrastructure remains adaptable to the rapidly evolving cyber threat landscape. 
\pagebreak

\section{Sources}
\begin{itemize}
    \item Morgan, S. (2013, November 13). Cybercrime To Cost The World \$10.5 Trillion Annually By 2025. Cybercrime Magazine. https://cybersecurityventures.com/hackerpocalypse-cybercrime-report-2016/
    \item Parol, P. (2020, April 22). P4 network programming language - what is it all about?. CodiLime. https://codilime.com/blog/p4-network-programming-language-what-is-it-all-about/
    \item Data Tech, A. (2022, January 27). What you should know about P4 programming language & P4 Programmable Switch. Medium. 
    https://medium.com/@Asterfusion/what-you-should-know-about-p4-programming-language-p4-programmable-switch-da4be7d271af
    \item McKeown, N. (2021, July 22). P4 runtime - putting the control plane in charge of the forwarding plane. Open Networking Foundation. https://opennetworking.org/news-and-events/blog/p4-runtime-putting-the-control-plane-in-charge-of-the-forwarding-plane/
    \item Cisco (2024) What Is MUD. https://developer.cisco.com/docs/mud/what-is-mud/#what-is-mud
    \item Su, Laura. (2019, May 31) MUD is officially approved by IETF as an Internet Standard, and Cisco is launching MUD1.0 to protect your IoT devices. https://blogs.cisco.com/security/mud-is-officially-approved-by-ietf-as-an-internet-standard-and-cisco-is-launching-mud1-0-to-protect-your-iot-devices
\end{itemize}
