<div class='section'>Relevant Resources</div><div class="itemize"><ul><li> <b>Relevant Lab:</b> Internet Real-Time Lab (IRT), Columbia University Department of Computer Science<li> <b>Research Advisors:</b> Luoyao Hao, Henning Schulzrinne<li> <b>Author Emails:</b> csl2192@columbia.edu, hk3187@columbia.edu<li> <b>Video Demonstration:</b> Click <a href="https://youtu.be/laNO6OkpahU" style="text-decoration: underline;">here</a> for my beautiful voice</ul></div><div class='section'>IoT Background Information</div><div class='subsection'>Modern, Escalating Cyber Threats</div>In the age of the internet, the economic impact of cybercrime continues to surge at an alarming rate. It is projected that in 2021, cybercrime inflicted global damages totaling \$6 trillion USD. This stark number is a testament to the increasing sophistication and frequency of cyberattacks faced by individuals, corporations, and governments worldwide. The economic trajectory of cybercrime costs reveals an even more daunting future, with projected growth rate of 15 percent YOY, reaching a monumental \$10.5 trillion USD annually by 2025. <br><br>In response to the rising tide of cyber threats, global spending on cybersecurity products is also seeing significant growth. Over the five-year period from 2021 to 2025, cumulative investment in cyber defense is estimated to have exceeded \$1 trillion USD. This substantial financial commitment reflects the critical need for advanced protective measures and the escalating demand within the constantly evolving space.$$\includegraphics[width=12cm]{SPENDING2025.png}$$Keeping pace with this dramatic increase in cybercrime is the rapid expansion of internet connectivity, with around one million new users going online each day. By 2023, the number of networked devices globally is predicted to triple the human population, presenting an unprecedented expansion in potential vulnerabilities. Furthermore, by 2022, the planet will host 1 trillion networked sensors, escalating to 45 trillion within a matter of two decades. This is also matched by exponential growth in IP traffic, which soared to an annual run rate of 2.3 zettabytes in 2020 from 870.3 exabytes in 2015. <br><br>Given the vast expansion of networked devices, there is a pressing need for innovative network protection strategies that can adapt to and secure an increasingly complex and vulnerable digital landscape.<div class='subsection'>Introduction to Firewalls</div>One example of these innovative strategies is the development of firewalls. In short, firewalls are indispensable for safeguarding digital assets and serve as the first line of defense in a network's security framework. They operate at the network's edge, scrutinizing incoming and outgoing traffic to prevent unauthorized access and block cyber threats. By enforcing security policies and filtering traffic based on predefined rules, firewalls reinforce the security perimeter, protecting sensitive data and networked systems from exploitation by malicious actors. As the number and complexity of cyber threats continue to grow, the role of firewalls evolves to offer more sophisticated, adaptive solutions that can dynamically respond to new vulnerabilities and attacks.<br><br>The modern implementations often utilize stateful inspection techniques. This method tracks the state of active connections and makes decisions about which network packets to allow through based on state, port, and protocol. Furthermore, firewalls can analyze the contents of the data packets, header information, and other aspects of transmissions which allows for more granular security decisions, effectively identifying and blocking packets with malicious data. Additionally, firewalls can be integrated with other security frameworks, creating a comprehensive security infrastructure that adapts to the constantly emerging threats.<div class='subsection'>Diverse Firewall Architectures</div>While this paper is principally centered on the P4 Firewall architecture at the switch level, it is essential to also have a robust grasp of other firewall types. This section delves into the modern implementations of diverse firewall technologies. Each variant, from network layer firewalls to application layer firewalls, serves a distinct role in a comprehensive multi-layered defense strategy, effectively enhancing the network's ability to counteract evolving cyber threats.<div class="itemize"><ul><li> <b>Session Layer Firewall:</b> These firewalls, also known as Circuit-Level Gateways, enhance network security by focusing on the integrity of session initiations. They employ robust session tracking mechanisms to verify the authenticity and authorization of network connections, significantly bolstering defenses against session hijacking and other protocol-specific attacks. By monitoring the state of network connections, these firewalls detect and prevent unauthorized access, ensuring the security of communication channels across the network.<li> <b>Application Layer Firewall:</b> These firewalls, also know as Proxy Firewalls, serve as critical intermediaries between end-users and the Internet. These firewalls intercept all inbound and outbound messages, conducting deep packet inspections to scrutinize both content and headers. Operating at the application level, they enforce rigorous user-level controls and perform extensive content filtering, thus providing superior security. Their ability to mask internal network addresses effectively shields against direct external attacks, enhancing overall network security.<li> <b>Network Layer Firewalls:</b> These firewalls operate at the IP level, analyzing and filtering network traffic based on IP addresses and port numbers. These systems enforce detailed router-protocol policies that manage intricate data flows, ensuring only authorized traffic accesses the network. Utilizing advanced packet filtering technologies, these firewalls inspect each packet's header for source and destination information, playing a pivotal role in preemptively blocking potentially harmful communications and protecting network integrity.</ul></div>At the forefront of firewall technology, P4-based Packet Filtering operates within the Network (IP) layer, leveraging the programmable nature of the P4 language to dynamically customize behaviors. This advanced capability allows firewalls to inspect, modify, and make real-time decisions on each packet, using complex match-action rules tailored to specific network needs. The inherent flexibility of P4-based systems enables the development of precise, adaptable security policies that can be continually refined.<div class='subsection'>Advantages of P4 Firewalls</div><div class='subsubsection'>Programmability</div>P4-based firewalls excel in their programmability, allowing network engineers to implement and modify custom firewall rules and policies directly within the data plane. This is achieved through the P4 language, which abstracts hardware complexities and provides a high level of control over the packet-processing logic. This programmability extends beyond simple firewall configurations to include sophisticated network functions such as traffic monitoring, load balancing, and more, all tailored to specific network requirements without the need for new hardware deployments.<div class='subsubsection'>High-Speed Performance</div>The high-speed performance of P4-based firewalls is unparalleled due to their direct implementation on the network hardware level. By processing packets at the hardware level, P4 firewalls can achieve linear-rate speeds, which is essential for maintaining network performance during high-volume traffic periods. This capability ensures that security measures do not become a bottleneck, thereby preserving the integrity and responsiveness of the network under all conditions.<div class='subsubsection'>Advanced Scalability</div>The scalability of P4-based firewalls provides a key advantage. Because these firewalls are deeply integrated into the network hardware and managed through flexible, programmable interfaces, they can effortlessly scale to handle increasing amounts of network traffic and more complex security protocols. The ability to dynamically adjust and scale security rules without degrading performance allows organizations to respond quickly to new threats and changes in network traffic patterns, maintaining robust security without compromising on performance.<div class='section'>Basics of P4 and P4Runtime</div><div class='subsection'>Introduction to P4</div>Developed by Professor Nick McKeown from Stanford University in 2013, P4 quickly became integral to software-defined networking (SDN). Its development underscored a shift from fixed-function network devices to more versatile, software-driven technologies, paving the way for innovative network management and operation solutions.<br><br>The P4 language is specifically designed for programmable network devices, enabling precise control over how network protocols are processed and handled. Its strength lies in its protocol independence, meaning it does not inherently support standard protocols like IP or TCP. Instead, programmers define the necessary packet protocols directly in the P4 program, which are then interpreted by the target hardware.<br><br>In traditional network switches, the hardware's functionality limits the data plane's capabilities. In contrast, P4 allows the data plane functions to be dynamically defined by the P4 program itself, enhancing flexibility and enabling the implementation of specific network functions tailored to unique requirements.<br>$$\includegraphics[width=12cm]{standard_and_p4-defined_switches.png}$$In most papers, you will see P4 described as adopting a "top-down" approach for network device programming. Specifically, we see that P4 programs define the desired network functionalities at a high level. These programs are then compiled and injected into the network device, requiring the hardware to support programmability. This method contrasts with the traditional "bottom-up" approach where the capabilities are defined by the hardware's fixed functions, limiting flexibility.$$\includegraphics[width=9cm]{bottom-up.png}$$For a more comprehensive understanding of the P4 programming language and to access hands-on tutorials, please visit the dedicated GitHub repository. This site offers a wealth of resources, including step-by-step guides, example projects, and community support, which were invaluable for our understanding of P4. Explore these resources by following the link provided <a href="https://github.com/p4lang/tutorials" style="text-decoration: underline;">here</a>.<div class='subsection'>Introduction to P4Runtime</div>It is crucial to distinguish between P4 Runtime and the P4 language, as they serve different but complementary purposes. As mentioned above, the P4 language is primarily used to define the processing behavior of packets within a switch, detailing the operations performed on packet fields and the sequence of these operations. However, P4 Runtime is an API that facilitates the actual control of these devices once their behavior has been defined using the P4 language. <br>$$\includegraphics[width=12cm]{p4runtime.png}$$With its development, P4 Runtime marked a groundbreaking new approach to managing the forwarding planes of network devices such as switches, routers, and firewalls. This protocol is unique because it allows control over any type of forwarding plane. The architecture of P4 Runtime is consistent across different device types, supporting a broad range of customizable protocols and features with the ability to manage a diverse array of network devices effectively (a plus for scalability of network systems). <br><br>Historically, network devices were managed through proprietary APIs that were fixed and closed. These APIs were designed specifically for certain chipsets and did not accommodate the dynamic addition of new features or protocols. Moreover, non-disclosure agreements and licensing constraints prevented these APIs from being shared or used to manage devices from different manufacturers. This limitation hindered innovation and flexibility in network management. P4 Runtime addresses these issues by providing a standardized and open API that evolves dynamically as new features are introduced to the network device, without requiring a restart or reboot of the control plane.<br><br>P4 Runtime's flexibility stems from its integration with the P4 programming language. Network developers can define device behavior using P4, and then use P4 Runtime to manage these behaviors dynamically. For instance, a developer might specify an IPv4 longest-prefix-match (LPM) table within a P4 program. The P4 compiler then automatically generates a schema based on this specification, which P4 Runtime uses to manage the table entries at runtime. This capability is not restricted to predefined functions; developers can extend or modify the P4 program to introduce new functionalities, like IPv6 prefix tables or custom rules for network traffic.<div class='subsection'>P4 Switch Architecture</div>Each endpoints are connected by P4's virtual switches that receives and forwards the packets according to the programmed match-action table. Once a switch receives a packet from its input ports, it extracts the fields from the header which describes the permitted sequences of headers within received packets, how to identify those header sequences, and the headers and fields to extract from packets.<br><br>In detail, to forward a packet in IPv4 forwarding, each switch will (i) update the source and destination MAC addresses, (ii) decrement the time-to-live (TTL) in the IP header, and (iii) forward the packet out the appropriate port. Each switch will maintain a match-action table which is updated by the control plane with some static rules. Each rule will map an IP address or other parts of header to the MAC address and output port for the next hop. When a rule matches a packet, its action such as forwarding or dropping is invoked with parameters supplied by the control plane as part of the rule. This rule can also be dynamically updated by P4 Runtime from the control plane. <br><br>As shown in the diagram below, the design of virtual switches can be broken down into input channel, parser, ingress match-action, buffer, egress match-action, and output channel.$$\includegraphics[width=12cm]{switch_arch.png}$$<div class='subsection'>P4 Runtime API</div>P4 is a language for programming the data plane of network devices. However, it lacks the flexibility of dynamically updating the match action table during the runtime. The P4Runtime API is a control plane specification for controlling the data plane elements in python which allows the developers to write controller applications for P4 devices or switches. <br><br>The figure below shows the pipeline of how Runtime API plays a role in P4 runtime. Once P4 program is written with the basic topology of the network and basic match-action behavior, it gets compiled with P4 compiler. The compiled information is used to create data plane runtime simulation including the table and extern objects in data plane. Then, Runtime API is used to construct control plane scripts that dynamically updates the tables in the data plane.$$\includegraphics[width=12cm]{p4_runtime.png}$$<div class='section'>Packet Rate & Size Monitoring Solution for IoT Firewall Rules</div><div class='subsection'>Overview of Project</div>The solution implemented within this section is designed to provide robust security measures directly at the switch level, effectively preventing malicious packet transmissions to targeted host IP addresses in a variety of scenarios. Specifically, this project is engineered in order to tailor to three core blocking functionalities, each used to intercept different types of network threats:<div class="itemize"><ul><li> <u>Packet Size Filtering</u>: This functionality blocks packets based on their size. It is designed to detect and prevent oversized or undersized packets which often signify malicious intent, such as buffer overflow attacks or malformed packet exploits.<li> <u>Arbitrary Host Blocking</u>: This feature allows network administrators to specify one or more host IP addresses that are to be completely blocked from sending packets within the network. This is particularly useful for isolating and mitigating threats from known malicious sources or compromised systems.<li> <u>Packet Rate Limiting</u>: To combat denial-of-service (DoS) attacks, our firewall includes a packet rate limiting feature. This function monitors the rate of incoming packets and automatically throttles or blocks traffic that exceeds predefined thresholds, ensuring that network resources are not overwhelmed by malicious traffic bursts.</ul></div>In each section, you will see the logic behind the implementation at both the switch and controller level as well as instructions on how to test on a clean-state Linux machine. For more details, please also reference the GitHub repository linked in the relevant materials section.<div class='subsection'>Network Topology</div><div class='subsubsection'>Subnet Implementation</div>Our project's network topology is designed to provide a robust and scalable structure for the deployment of our voice analysis tools. The network is primarily structured around three switches (<code style="color: white !important; text-decoration: none !important;">s1, s2, s3</code>) and three hosts (<code style="color: white !important; text-decoration: none !important;">h1, h2, h3</code>). Below, we provide an overview of the topology along with the configuration details of the hosts and the interconnections between the hosts and switches.<br><br>Here is the JSON configuration that specifies the IP addresses, MAC addresses, and routing commands for each host, as well as the connections that define the network topology:<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hosts&quot;:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;h1&quot;:&nbsp;{&quot;ip&quot;:&nbsp;&quot;10.0.1.1/24&quot;,&nbsp;&quot;mac&quot;:&nbsp;&quot;08:00:00:00:01:11&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;commands&quot;:[&quot;route&nbsp;add&nbsp;default&nbsp;gw&nbsp;10.0.1.10&nbsp;dev&nbsp;eth0&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;arp&nbsp;-i&nbsp;eth0&nbsp;-s&nbsp;10.0.1.10&nbsp;08:00:00:00:01:00&quot;]},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;h2&quot;:&nbsp;{&quot;ip&quot;:&nbsp;&quot;10.0.2.2/24&quot;,&nbsp;&quot;mac&quot;:&nbsp;&quot;08:00:00:00:02:22&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;commands&quot;:[&quot;route&nbsp;add&nbsp;default&nbsp;gw&nbsp;10.0.2.20&nbsp;dev&nbsp;eth0&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;arp&nbsp;-i&nbsp;eth0&nbsp;-s&nbsp;10.0.2.20&nbsp;08:00:00:00:02:00&quot;]},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;h3&quot;:&nbsp;{&quot;ip&quot;:&nbsp;&quot;10.0.3.3/24&quot;,&nbsp;&quot;mac&quot;:&nbsp;&quot;08:00:00:00:03:33&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;commands&quot;:[&quot;route&nbsp;add&nbsp;default&nbsp;gw&nbsp;10.0.3.30&nbsp;dev&nbsp;eth0&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;arp&nbsp;-i&nbsp;eth0&nbsp;-s&nbsp;10.0.3.30&nbsp;08:00:00:00:03:00&quot;]}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;switches&quot;:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;s1&quot;:&nbsp;{&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;s2&quot;:&nbsp;{&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;s3&quot;:&nbsp;{&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;links&quot;:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;h1&quot;,&nbsp;&quot;s1-p1&quot;],&nbsp;[&quot;h2&quot;,&nbsp;&quot;s2-p2&quot;],&nbsp;[&quot;h3&quot;,&nbsp;&quot;s3-p3&quot;],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;s1-p2&quot;,&nbsp;&quot;s2-p1&quot;],&nbsp;[&quot;s1-p3&quot;,&nbsp;&quot;s3-p1&quot;],&nbsp;[&quot;s2-p3&quot;,&nbsp;&quot;s3-p2&quot;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>Below is the visual representation of this topology.$$\includegraphics[width=10cm]{pod-topo.png}$$<div class='subsubsection'>Testing: Starting the Mininet</div>Start on a clean-state Linux machine, and navigate to the Virtual Machine. For more instructions on installing the virtual machine, please see the <a href="https://github.com/p4lang/tutorials?tab=readme-ov-file#obtaining-required-software" style="text-decoration: underline;">P4 Tutorials Repository</a>. Once you are in the Virtual machine,<ol class="enumerate"><li> Enter the p$4$ user profile and open the terminal. Navigate to the tutorials $\rightarrow$ IoTFirewall folder, and <code style="color: white !important; text-decoration: none !important;">make clean</code>.<li> Next, use <code style="color: white !important; text-decoration: none !important;">make</code> to create the mininet.<li> In the mininet terminal, use <code style="color: white !important; text-decoration: none !important;">xterm h1 h2 h3</code> to create terminals for the 3 host devices<li> In a separate terminal (outside of the mininet), run <code style="color: white !important; text-decoration: none !important;">sudo python3 controller.py</code> to start up your controller.</ol>Now, we can begin testing. The controller should show all three hosts connected.<div class='subsubsection'>Testing: Sending Packets</div>In order to first ensure that mininet is working, let's try to send/receive basic packets across the multiple host devices. To do this, simply follow these instructions within the terminals for the devices <code style="color: white !important; text-decoration: none !important;">h1, h2, h3</code> created within the mininet:<ol class="enumerate"><li> In the <code style="color: white !important; text-decoration: none !important;">h2, h3</code> terminals, run <code style="color: white !important; text-decoration: none !important;">sudo python3 receive.py</code><li> In the <code style="color: white !important; text-decoration: none !important;">h1</code> terminal, run <code style="color: white !important; text-decoration: none !important;">sudo python3 send.py h2/h3 'Arsenal will bottle the Premier League'</code></ol>In the controller terminal, it should show that <code style="color: white !important; text-decoration: none !important;">h1</code> is sending packets. On top of that, you should also see in the <code style="color: white !important; text-decoration: none !important;">h1, h2, h3</code> terminals that packets are being sent recieved across the devices.<div class='subsection'>Match-Action Table Changes</div>Our current network leverages P4-based IPv4 forwarding, which routes packets based on destination IP addresses. To bolster security, our project requires the implementation of advanced IP blocking strategies: blocking traffic to and from specific destination and source IPs. This necessitates sophisticated modifications to the P4 match-action tables, enabling precise filtering of both incoming and outgoing packets based on IP criteria.<div class='subsubsection'>Dropping by Destination IP</div>To implement destination IP-based blocking, we introduced modifications to the <code style="color: white !important; text-decoration: none !important;">utils/p4runtime_lib/</code><code style="color: white !important; text-decoration: none !important;">switch.py</code> file, adding specialized functions that enable dynamic updates to the forwarding rules in the P4 Runtime's behavioral model (bmv2). One critical function, <code style="color: white !important; text-decoration: none !important;">DeleteTableEntry</code>, is designed to remove existing table entries that dictate packet forwarding behaviors, replacing them with rules that instead drop packets to specific IP addresses:<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;DeleteTableEntry(self,&nbsp;table_entry,&nbsp;dry_run=False):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request&nbsp;=&nbsp;p4runtime_pb2.WriteRequest()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.device_id&nbsp;=&nbsp;self.device_id<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.election_id.low&nbsp;=&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update&nbsp;=&nbsp;request.updates.add()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update.type&nbsp;=&nbsp;p4runtime_pb2.Update.DELETE<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update.entity.table_entry.CopyFrom(table_entry)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dry_run:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;P4Runtime&nbsp;Delete:&nbsp;&quot;,&nbsp;request)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.client_stub.Write(request)<br></code></div>In the context of our P4 program (<code style="color: white !important; text-decoration: none !important;">basic.p4</code>), the <code style="color: white !important; text-decoration: none !important;">ipv4_lpm</code> table plays a pivotal role in this mechanism. Initially configured for longest prefix matching (LPM) to route packets based on destination IP addresses, we have enhanced this table to include an action that enables packet dropping:<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;table&nbsp;ipv4_lpm&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdr.ipv4.dstAddr:&nbsp;lpm;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipv4_forward;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoAction;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;1024;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default_action&nbsp;=&nbsp;drop();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>The blocking functionality is enacted through a controller mechanism that first deletes the existing forwarding rule and then builds/writes new table entries. These entries explicitly instruct the switch to drop packets matching the designated destination IP address, effectively nullifying any previous forwarding rules:<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;table_entry&nbsp;=&nbsp;p4info_helper.buildTableEntry(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table_name=&quot;MyIngress.ipv4_lpm&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match_fields={<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hdr.ipv4.dstAddr&quot;:&nbsp;(dst_ip_addr,&nbsp;32)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action_name=&quot;MyIngress.ipv4_forward&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action_params={<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dstAddr&quot;:&nbsp;dst_eth_addr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;port&quot;:&nbsp;port,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dst_id&quot;:&nbsp;dst_id<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;ingress_sw.DeleteTableEntry(table_entry,&nbsp;False)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Change&nbsp;to&nbsp;drop&nbsp;func<br>&nbsp;&nbsp;&nbsp;&nbsp;table_entry&nbsp;=&nbsp;p4info_helper.buildTableEntry(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table_name=&quot;MyIngress.ipv4_lpm&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match_fields={<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hdr.ipv4.dstAddr&quot;:&nbsp;(dst_ip_addr,&nbsp;32)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action_name=&quot;MyIngress.drop&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;ingress_sw.WriteTableEntry(table_entry)<br></code></div><div class='subsubsection'>Dropping by Source IP</div>In conventional P4 applications, IP forwarding primarily utilizes destination IP addresses (<code style="color: white !important; text-decoration: none !important;">dst_addr</code>). To enhance network security controls, our project introduces a novel mechanism to block traffic based on source IP addresses (<code style="color: white !important; text-decoration: none !important;">src_addr</code>). This addition necessitates the creation of a new table within our P4 program specifically for managing rules associated with source addresses, which differs fundamentally from the existing destination-based approaches.<br><br>To facilitate this new functionality, we first define a metadata structure to track whether a packet should be dropped. The metadata includes a bit (<code style="color: white !important; text-decoration: none !important;">src_lpm_hit</code>) which is set to $1$ when a packet meets the drop criteria.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;metadata&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bit&lt;1&gt;&nbsp;src_lpm_hit;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;other&nbsp;metadata&nbsp;fields...&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;action&nbsp;drop()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark_to_drop(standard_metadata);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta.src_lpm_hit&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>Now, we define a new table, <code style="color: white !important; text-decoration: none !important;">ipv4_src_lpm</code>, which utilizes longest prefix matching (LPM) on the source IP address and includes actions to handle different packet scenarios. The default action of this table is to set the <code style="color: white !important; text-decoration: none !important;">src_lpm_hit</code> bit to 0, indicating that the packet has not been marked for dropping under normal circumstances.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;table&nbsp;ipv4_src_lpm&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdr.ipv4.srcAddr:&nbsp;lpm;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoAction;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_src_lpm_hit_to_zero;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;1024;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default_action&nbsp;=&nbsp;set_src_lpm_hit_to_zero();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>Within the MyIngress control block, the source IP blocking table is applied prior to any destination-based forwarding decisions. This sequential application ensures that packets are first checked against the source IP blocking rules. If a packet is not marked as dropped (<code style="color: white !important; text-decoration: none !important;">src_lpm_hit == 0</code>), it is then evaluated by the destination IP forwarding rules.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hdr.ipv4.isValid()&nbsp;&amp;&amp;&nbsp;!hdr.myTunnel.isValid())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipv4_src_lpm.apply();&nbsp;&nbsp;//&nbsp;Apply&nbsp;source&nbsp;IP&nbsp;blocking&nbsp;rules<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(meta.src_lpm_hit&nbsp;==&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipv4_lpm.apply();&nbsp;&nbsp;//&nbsp;Proceed&nbsp;with&nbsp;destination&nbsp;IP&nbsp;forwarding<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;----&nbsp;Rest&nbsp;of&nbsp;the&nbsp;processing&nbsp;logic&nbsp;----<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>To populate and modify the <code style="color: white !important; text-decoration: none !important;">ipv4_src_lpm</code> table at runtime, we define a function blockTableEntry2, which interfaces with the P4 Runtime to dynamically insert drop rules based on source IP addresses. This will be used dynamically in many of the functionalities we want to implement at the controller level.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;blockTableEntry2(p4info_helper,&nbsp;ingress_sw,&nbsp;src_ip_addr):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table_entry&nbsp;=&nbsp;p4info_helper.buildTableEntry(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table_name=&quot;MyIngress.ipv4_src_lpm&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match_fields={<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hdr.ipv4.srcAddr&quot;:&nbsp;(src_ip_addr,&nbsp;32)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action_name=&quot;MyIngress.drop&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ingress_sw.WriteTableEntry(table_entry);<br></code></div>The diagram below illustrates the integration of this mechanism within our network topology, outlining the flow of packet processing through the newly defined tables for <code style="color: white !important; text-decoration: none !important;">src_addr</code> blocking.$$\includegraphics[width=13cm]{blocker-demo (1).png}$$<div class='subsection'>Packet Size Firewall</div><div class='subsubsection'>Implementation Notes</div>The first part of the project implements a proactive security measure by integrating a packet-size based firewall rule within our P4-enabled switch. This rule is designed to identify and mitigate potential attacks characterized by unusually large packet sizes, which are often indicative of malicious activities such as buffer overflow attacks or other denial-of-service (DoS) strategies.<br><br>The firewall rule is defined using a constant that specifies the maximum allowable packet size, set to $1024$ bytes ($1 \ll 10$). This threshold is chosen based on typical network traffic patterns and the specific security requirements of our infrastructure.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Defined&nbsp;outside&nbsp;of&nbsp;Ingress<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;bit&lt;16&gt;&nbsp;MAX_PACKET_SIZE&nbsp;=&nbsp;1&nbsp;&lt;&lt;&nbsp;10;<br></code></div>During the packet processing phase within the Ingress control block, each incoming packet's total length is checked against this maximum value. If a packet's size exceeds the defined maximum, it is immediately marked for dropping. This decision is enforced by invoking the <code style="color: white !important; text-decoration: none !important;">mark_to_drop</code> action on the <code style="color: white !important; text-decoration: none !important;">standard_metadata</code>, effectively filtering out oversized packets before they can traverse the network.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Defined&nbsp;inside&nbsp;Ingress&nbsp;Processing<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hdr.ipv4.totalLen&nbsp;&gt;&nbsp;MAX_PACKET_SIZE)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark_to_drop(standard_metadata);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>It is important to note that this implementation is done entirely at the level of the switch, with no involvement from the controller.<div class='subsubsection'>Testing Instructions</div>To show this blocking functionality works, let's assume that you've set up the mininet console and have terminals for <code style="color: white !important; text-decoration: none !important;">h1, h2, h3</code>.<ol class="enumerate"><li> Once you've completed the above, in the terminal for <code style="color: white !important; text-decoration: none !important;">h2, h3</code>, run <code style="color: white !important; text-decoration: none !important;">sudo python3 receive.py</code><li> If you want to test that regular packets are going through, run <code style="color: white !important; text-decoration: none !important;">sudo python3 send.py h2/h3 'I love P4'</code> in the terminal for <code style="color: white !important; text-decoration: none !important;">h1</code><li> Now, to show that packets are being dropped, run <code style="color: white !important; text-decoration: none !important;">sudo python3 large-send.py h2/h3</code> which will send a packet of size $\geq 2^{10} = 1024$. If the functionality works, you should see that no packets are being received by <code style="color: white !important; text-decoration: none !important;">h2, h3</code>.<li> (Optional) Run Step 2 again to show that regular size packets are still being sent through!</ol><div class='subsection'>Identified Threat Firewall</div><div class='subsubsection'>Implementation Notes</div>The system is designed around a control plane that communicates with network devices via UDP sockets. This method allows for rapid signaling between hosts and the controller, facilitating immediate security actions based on detected threats.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;UDP&nbsp;send:&nbsp;block.py&nbsp;--&gt;&nbsp;controller.py<br>&nbsp;&nbsp;&nbsp;&nbsp;UDPClientSocket&nbsp;=&nbsp;socket.socket(family=socket.AF_INET,&nbsp;type=socket.SOCK_DGRAM)<br>&nbsp;&nbsp;&nbsp;&nbsp;UDPClientSocket.sendto(b&#x27;1&#x27;,&nbsp;(&quot;127.0.0.1&quot;,&nbsp;20001))<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Listening&nbsp;on&nbsp;the&nbsp;socket<br>&nbsp;&nbsp;&nbsp;&nbsp;UDPServerSocket&nbsp;=&nbsp;socket.socket(family=socket.AF_INET,&nbsp;type=socket.SOCK_DGRAM)<br>&nbsp;&nbsp;&nbsp;&nbsp;UDPServerSocket.bind((&quot;127.0.0.1&quot;,&nbsp;20001))<br>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;True:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytesAddressPair&nbsp;=&nbsp;UDPServerSocket.recvfrom(1024)<br></code></div>In a scenario where host <code style="color: white !important; text-decoration: none !important;">h2</code> is identified as a source of malicious activity, the system allows for the immediate disconnection and blocking of this host from switch <code style="color: white !important; text-decoration: none !important;">s1</code>. The blocking operation is executed by sending a UDP message from the blocking script (<code style="color: white !important; text-decoration: none !important;">block.py</code>) on <code style="color: white !important; text-decoration: none !important;">h2</code> to the controller. Upon receiving this signal, the controller executes table rewriting functions defined in the P4 program, which instruct switch <code style="color: white !important; text-decoration: none !important;">s1</code> to drop all incoming packets from <code style="color: white !important; text-decoration: none !important;">h2</code>.<br><br>Below is a diagram that accompanies the description above, illustrating the communication flow and interaction between the host, the controller, and the switch.$$\includegraphics[width=10cm]{Screenshot 2024-05-02 at 2.41.48 PM.png}$$<div class='subsubsection'>Testing Instructions</div>To show how this functionality works, let's assume that you've set up the mininet console, <code style="color: white !important; text-decoration: none !important;">controller.py</code>, and have terminals for <code style="color: white !important; text-decoration: none !important;">h1, h2, h3</code>.<ol class="enumerate"><li> Once you've completed the above, in the terminal of <code style="color: white !important; text-decoration: none !important;">h1, h3</code>, run <code style="color: white !important; text-decoration: none !important;">sudo python3 receive.py</code><li> We want to see that regular packets are going through to the host devices. So, run <code style="color: white !important; text-decoration: none !important;">sudo python3 send.py h1/h3 'I love P4'</code> in the terminal for <code style="color: white !important; text-decoration: none !important;">h2</code><li> In a new terminal outside of the mininet, run <code style="color: white !important; text-decoration: none !important;">sudo python3 block.py h2</code>. Now, <code style="color: white !important; text-decoration: none !important;">h2</code> should be blocked at <code style="color: white !important; text-decoration: none !important;">s1</code>. In the original <code style="color: white !important; text-decoration: none !important;">controller.py</code> terminal, you should see that <code style="color: white !important; text-decoration: none !important;">s2</code> is disconnected.<li> Finally, try sending packets through. In the <code style="color: white !important; text-decoration: none !important;">h2</code> terminal, try running <code style="color: white !important; text-decoration: none !important;">sudo python3 send.py h1/h3 'I love Arsenal'</code>. You should see that the controller and <code style="color: white !important; text-decoration: none !important;">h2</code>-terminal are both registering sending packets, which are being received by <code style="color: white !important; text-decoration: none !important;">h3</code> but not <code style="color: white !important; text-decoration: none !important;">h1</code>.</ol><div class='subsection'>Packet Rate Firewall</div><div class='subsubsection'>Implementation Notes</div>The core of our packet-rate monitor is built around P4's native counters, which function analogously to arrays in general-purpose programming languages. For more information on counters, please visit this site <a href="https://cornell-pl.github.io/cs6114/lecture07.html" style="text-decoration: underline;">here</a>. <br><br>In this implementation, we first introduce a counter, <code style="color: white !important; text-decoration: none !important;">h_counter</code>, within the Ingress control block of the switch's P4 program. This counter is tasked with tracking both the packet and byte counts based on unique identifiers derived from IP addresses.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Counter&nbsp;definition<br>&nbsp;&nbsp;&nbsp;&nbsp;counter(MAX_ID,&nbsp;CounterType.packets_and_bytes)&nbsp;h_counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Ingress&nbsp;processing&nbsp;logic<br>&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hdr.ipv4.isValid()&nbsp;&amp;&amp;&nbsp;!hdr.myTunnel.isValid())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipv4_lpm.apply();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hdr.ipv4.flags[1:1]&nbsp;==&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bit&lt;32&gt;&nbsp;lastTwoParts&nbsp;=&nbsp;(bit&lt;32&gt;)&nbsp;(hdr.ipv4.srcAddr&nbsp;&amp;&nbsp;0x0000FFFF);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h_counter.count(lastTwoParts);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hdr.ipv4.totalLen&nbsp;&gt;&nbsp;MAX_PACKET_SIZE)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark_to_drop(standard_metadata);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hdr.myTunnel.isValid())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myTunnel_exact.apply();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>This segment tracks packets originating from non-tunneled IPv4 sources. The counter incrementally logs entries based on the last two octets of the source IP address, effectively segmenting count data per subnet. To access and manipulate these counters dynamically, we implemented a <code style="color: white !important; text-decoration: none !important;">counterFinder</code> function within the controller environment. This function fetches real-time packet count data from specified indices, enabling on-the-fly traffic analysis.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;counterFinder(p4info_helper,&nbsp;sw,&nbsp;counter_name,&nbsp;index):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;response&nbsp;in&nbsp;sw.ReadCounters(p4info_helper.get_counters_id(counter_name),&nbsp;index):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;entity&nbsp;in&nbsp;response.entities:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;=&nbsp;entity.counter_entry<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;counter.data.packet_count<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch(Exception&nbsp;e)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Error&nbsp;when&nbsp;reading&nbsp;counter&nbsp;at&nbsp;index&nbsp;{index}:&nbsp;{e}&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></div>The system employs a <code style="color: white !important; text-decoration: none !important;">packetratetracker</code> function in the controller, which periodically reads the counter values to monitor the packet rate. If a significant deviation from the norm is detected, indicating potential malicious activity, an automated response is triggered to block the offending device.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;packet_rate_tracker(p4info_helper,&nbsp;ingress_sw):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Monitors&nbsp;the&nbsp;packet&nbsp;rate&nbsp;from&nbsp;specific&nbsp;hosts&nbsp;and&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blocks&nbsp;traffic&nbsp;if&nbsp;a&nbsp;threshold&nbsp;is&nbsp;exceeded.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p4info_helper:&nbsp;An&nbsp;instance&nbsp;of&nbsp;the&nbsp;P4Info&nbsp;helper&nbsp;utility.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ingress_sw:&nbsp;The&nbsp;ingress&nbsp;switch&nbsp;instance&nbsp;where&nbsp;the&nbsp;monitoring&nbsp;is&nbsp;applied.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&lt;-----&nbsp;Network&nbsp;Topology&nbsp;Var&nbsp;Definitions&nbsp;Excluded&nbsp;-------&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Initialize&nbsp;tracker&nbsp;for&nbsp;previous&nbsp;packet&nbsp;count<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previous_count&nbsp;=&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Continuous&nbsp;monitoring&nbsp;loop&nbsp;with&nbsp;a&nbsp;sleep&nbsp;interval&nbsp;of&nbsp;5&nbsp;seconds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;True:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;ip_tracks[ingress_sw.name]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;=&nbsp;get_last_two_parts(ip)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Fetch&nbsp;the&nbsp;new&nbsp;packet&nbsp;count&nbsp;from&nbsp;the&nbsp;counter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_count&nbsp;=&nbsp;counterFinder(p4info_helper,&nbsp;ingress_sw,&nbsp;&quot;MyIngress.h_counter&quot;,&nbsp;index)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Check&nbsp;if&nbsp;the&nbsp;change&nbsp;in&nbsp;count&nbsp;exceeds&nbsp;the&nbsp;threshold<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;abs(new_count&nbsp;-&nbsp;previous_count)&nbsp;&gt;=&nbsp;100:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Block&nbsp;the&nbsp;host&nbsp;if&nbsp;threshold&nbsp;is&nbsp;exceeded<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockTableEntry2(p4info_helper,&nbsp;ingress_sw,&nbsp;block_switch_info)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Update&nbsp;the&nbsp;tracker&nbsp;and&nbsp;optionally&nbsp;print&nbsp;the&nbsp;current&nbsp;count<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previous_count&nbsp;=&nbsp;new_count<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;printCounter(p4info_helper,&nbsp;ingress_sw,&nbsp;&quot;MyIngress.h_counter&quot;,&nbsp;index)<br></code></div>A diagram detailing the specifics behind the implementation is also included below.$$\includegraphics[width=10cm]{packet-rate-demo (3).png}$$In a practical scenario, consider host <code style="color: white !important; text-decoration: none !important;">h1</code> exhibiting suspicious network behavior. The switch <code style="color: white !important; text-decoration: none !important;">s1</code>, upon detecting an abnormal packet rate from <code style="color: white !important; text-decoration: none !important;">h1</code>, is programmed to automatically inhibit further packet transmissions from this source. This preemptive action is designed to mitigate any possible damage from distributed denial-of-service (DDoS) attacks or other malicious disruptions.<div class='subsubsection'>Testing Instructions</div>If you haven't restarted the mininet after the arbitrary blocking functionality, make sure to do that. If you are unsure of how to do this, reference the section called "Starting the Mininet".<ol class="enumerate"><li> Once you've set up the subnet topology, in the <code style="color: white !important; text-decoration: none !important;">h2</code> terminal, run <code style="color: white !important; text-decoration: none !important;">sudo python3 receive.py</code>.<li> We want to show that regular packets are allowed to be sent through. So, in <code style="color: white !important; text-decoration: none !important;">h1</code> terminal, run <code style="color: white !important; text-decoration: none !important;">sudo python3 send.py</code> <code style="color: white !important; text-decoration: none !important;">h2 'Chelsea forever'</code>.<li> Now, we want to test the spam blocking functionality. In the <code style="color: white !important; text-decoration: none !important;">h1</code> terminal, run <code style="color: white !important; text-decoration: none !important;">sudo python3 spam-send.py h2 --duration</code> <code style="color: white !important; text-decoration: none !important;">10 'i love p4'</code>. This is a program designed to spam send packets from <code style="color: white !important; text-decoration: none !important;">h1</code> $\rightarrow$ <code style="color: white !important; text-decoration: none !important;">h2</code>.<li> In the <code style="color: white !important; text-decoration: none !important;">controller.py</code> terminal, you should see that <code style="color: white !important; text-decoration: none !important;">h1</code> is disconnected.<li> To be sure, try sending a packet to <code style="color: white !important; text-decoration: none !important;">h2</code> using <code style="color: white !important; text-decoration: none !important;">sudo python3 send.py h2 'I love P4444'</code> in the <code style="color: white !important; text-decoration: none !important;">h1 terminal</code>.</ol><div class='subsection'>Future Direction of Project</div>As our project continues to evolve, we aim to significantly enhance and expand the capabilities of our network security infrastructure. The following areas highlight our key focus for future developments:<br><br><b>Enhancing Existing Features:</b><div class="itemize"><ul><li> <u>Scalability and Improvement of Blocking Features</u>: We plan to refine and scale our current blocking mechanisms to handle higher traffic volumes and more complex threat scenarios efficiently. This will include optimizing our P4 programs and control plane logic to ensure faster and more reliable response times.<li> <u>Integration with External Threat Intelligence</u>: As with Heeyun's project, we intend to incorporate external threat data into our blocking logic. This integration will allow us to dynamically adjust our security measures based on real-time threat analysis and intelligence, enhancing our ability to preemptively block identified threats.<li> <u>Dynamic Packet Rate Monitoring</u>: Future developments could involve improving our packet rate monitoring by enhancing the dynamic nature of our control plane's dictionary. This involves leveraging <code style="color: white !important; text-decoration: none !important;">packet_in/packet_out</code> functionality to allow real-time updates and adjustments to our monitoring and blocking strategies based on observed network conditions.<li> <u>Adaptive Traffic Rate Controls</u>: Further developments will also focus on dynamically updating acceptable traffic rates. This will adapt to varying network conditions and usage patterns, ensuring optimal performance without compromising on security.</ul></div><b>Introducing New Features</b>:<div class="itemize"><ul><li> <u>Dynamic Firewall Rule Updates</u>: Testing and implementing dynamic rule updates will be a priority. This involves creating a more flexible and responsive firewall system that can adjust its rules without manual intervention, based on the network state and emerging threats.<li> <u>Deep Packet Inspection (DPI)</u>: Possibly implementing DPI to enhance our ability to detect and respond to sophisticated threats that require analysis beyond basic header information. DPI will allow for a more granular look at the packet content, enabling precise blocking of malicious traffic.<li> <u>Protocol-Specific Features</u>: Updates will include developing features targeted at specific protocols. This will address unique vulnerabilities and optimize security measures tailored to protocol-specific characteristics and risks.</ul></div>These future directions are designed to not only enhance the robustness and efficiency of our network security measures but also to ensure that our infrastructure remains adaptable to the rapidly evolving cyber threat landscape.<div class='section'>Sources</div><div class="itemize"><ul><li> Morgan, S. (2013, November 13). Cybercrime To Cost The World \$10.5 Trillion Annually By 2025. Cybercrime Magazine. https://cybersecurityventures.com/hackerpocalypse-cybercrime-report-2016/<li> Parol, P. (2020, April 22). P4 network programming language - what is it all about?. CodiLime. https://codilime.com/blog/p4-network-programming-language-what-is-it-all-about/<li> Data Tech, A. (2022, January 27). What you should know about P4 programming language & P4 Programmable Switch. Medium.https://medium.com/@Asterfusion/what-you-should-know-about-p4-programming-language-p4-programmable-switch-da4be7d271af<li> McKeown, N. (2021, July 22). P4 runtime - putting the control plane in charge of the forwarding plane. Open Networking Foundation. https://opennetworking.org/news-and-events/blog/p4-runtime-putting-the-control-plane-in-charge-of-the-forwarding-plane/<li> Cisco (2024) What Is MUD. https://developer.cisco.com/docs/mud/what-is-mud/#what-is-mud<li> Su, Laura. (2019, May 31) MUD is officially approved by IETF as an Internet Standard, and Cisco is launching MUD1.0 to protect your IoT devices. https://blogs.cisco.com/security/mud-is-officially-approved-by-ietf-as-an-internet-standard-and-cisco-is-launching-mud1-0-to-protect-your-iot-devices</ul></div>