<div class='section'>NLP Cheatsheet - Final Exam</div><b>$[$0$]$ HMM</b> (1) Finite num states (2) Probabilistic transitions (3) Next state determined only by the current state, Markov property (4) Unsure which state weâ€™re in, current state emits observation <br><br><u>Viterbi Algorithm:</u> Dynamic programming algo that [1] sets up probability matrix for each state given observation [2] update matrix for every new observation, calculating based on previous states & observation probabilities [3] Determine the most probable sequence of states by tracing the path with the highest matrix prob.<br><br><u>Baye's Rule</u>:$$P(c = \text{POS}|\text{good}) = \frac{P(c = \text{POS}) \cdot P(\text{good}|c = \text{POS})}{P(\text{good})}$$

<u>Transformer Model:</u>

<div style="display: flex; justify-content: center; align-items: center; padding: 20px; height: 500px;">
    <img src="https://media.licdn.com/dms/image/D4D12AQHDPZzjJinK7A/article-inline_image-shrink_1000_1488/0/1709682962648?e=1721865600&v=beta&t=dj9nWRkTWfEjVF2FKoUBnJkd9w7mOH-a0qkhpVGR1zw" alt="Image" style="height: 300px; border: 5px solid black; transform: rotate(90deg);">
</div>

<b>$[$1$]$ RNN:</b> Feed-forward networks that are rolled out over time, slow to train, vanishing gradient problem for long seq<br><b>$[$2$]$ LSTM:</b> Made to solve vanishing gradient, has branch that allows passing information to skip the long processing of the current cell, branch allows NN to retain memory for a longer, still suffers from vanishing gradient for complex seq<br><b>$[$3$]$ Transformers:</b> Uses self-attention, can pass all the words in seq (parallelization to use GPUs) and determine the word embedding simultaneously, encoder passes all states (even hidden ones) to decoder. Compared to RNN, transformers have residual connections; intuitively, their summation operations "form a path" in the computation graphs where the gradient does not get lost. <br><br><b>$[$4$]$ Encoder:</b><ol class="enumerate"><li> <u>Multi-headed attention</u>: Focuses on how relevant a particular word is wrt other words in the sentence, represented as an attention vector. Multiple attention vectors per word and weighted average to compute the final attention vector of every word.<li> <u>Feed-forward network</u>: Transform the attention vectors into a form that is acceptable to the next encoder or decoder layer, attention vectors are independent so we can parallelize</ol><b>[5] Decoder</b>:<ol class="enumerate"><li> <u>Masked multi-head attention</u>: Hide future words so model only considers input seq and already generated target (English seq and partial French seq). While parallelizing, the matrix is modified by"masking" - turning attention scores into $0$'s for future words (no info leak).<li> <u>Feed-forward, Softmax</u>: takes the attention-informed representation of the input and transforms it into a probability distribution for next words in target seq, using non-linear softmax</ol><b>[6] Decoder (pre-output)</b>:<ol class="enumerate"><li> Checks each hidden state received since every HS is mostly associated with a particular word of the input sentence AND gives each HS a score.<li> Each score is multiplied by its respective softmax score, amplifying hidden states with high scores and drowning out hidden states with low scores.</ol><b>[7] The Larger Process (decoder):</b><ol class="enumerate"><li> Start with the embedding of the $\langle$END$\rangle$ token. Initialize with the first decoder hidden state. RNN processes and produces HS $h4$.<li> Use $h4$ vector and encoder hidden states to calculate context vector $C4$, which captures the relevant parts of the input seq for this specific time step. Then, combine the $h4$ and $C4$ vectors.<li> Pass this new vector into the feed-forward NN, which will make predictions for next words in target seq. Repeat for every subsequent word.</ol><b>[8] Character vs. Word Tokenization</b>: Character-based toeknization allows for a greatly reduced memory and time complexity during computation (since there are less characters). During model training and inference, you will see fewer out-of-vocabulary (OOV) instances; you can always represent unseen words with their character encodings. However, the trade-off is with semantic meaning and relationships between words, which is often lost in character-based tokenizations.<br><br><b>[9] K-Beam Search</b>: Beam-search keeps a $k$ number of beams (a hyperparameter), or options, at each time step, picking the most probable overall sequences based on their joint probabilities. At each time step, only $k$ beams are kept; sequences with lower joint probabilities are pruned. Better than greedy for longer, more probable sequences.<br><br><b>[10] Autoregressive Model</b>: No encoder, these models often consist of a single stack of transformer layers (like GPT models), handling both the understanding of input context and the generation of output sequentially. Generate output tokens one at a time, they use embeddings, positional encodings to convert words into vectors and understand their sequence. Prompts look like "Input: Hello World! Output: " whereas encoder decoders are simply "Hello World". It's also possible to structure all NLP tasks so that an autoregressive model clutches up. <br><br><b>[11] Summarization</b>: [1] Informative (Replacing a document) vs. Indicative (describing the contents of a document) [2] Extractive (Choosing bits of the source) vs. Generative (abstractive) (generating something new) [3] Single document vs. Multi Document [4] Generic vs. user-focused<div class="itemize"><ul><li> <u>Difficulties</u>: Requires both interpretation and generation of text, handle input documents from unrestricted domains robustly, operate without full semantic interpretation, sentence selection seems optimal<li> <u>Types</u>: Extraction (selection) is not optimal since it can be misleading with extraneous phrases and dangling noun phrases and pronouns. Cut & Paste: [1]  Sentence compression [2] Sentence fusion [3] Syntactic transformation [4] Lexical paraphrasing. Attention-based (ABS) performs abstractive summarization (Paraphrasing, compression)</ul></div><b>[12] BART</b>: Originated from BERT (Bidirectional Encoder Representations from Transformers). BART (Bidirectional and Auto-Regressive Transformers). Uses a bidirectional encoder and left-to-right autoregressive decoder (like GPT). Learns a model to reconstruct original text from corrupted noisy text. It is pre-trained on noisy documents; optimizes cross-entropy loss between decoder output and original (reconstruction).<div class="itemize"><ul><li> <u>Types of Noise</u>: [1] Token masking (fill in the blank), MLM from BERT [2] Token Deletion, deleting random tokens from input (model decides what is missing) [3] Text infilling, replaces spans with single $\langle\text{MASK}\rangle$ token and model decides how many tokens are missing. [4] Sentence Permutation, shuffles sentences [5] Document Rotation, starts at some random point in the document and model decides where start token is</ul></div><b>[13] Spoken Dialog Systems</b>: ASR (automatic speech recognizer) turns speech to text, TTS (text to speech), Recognition, Language Understanding (understanding purpose/intent of comm) converts words to structure, Manipulation of utterances (reformulating user input, clarification, simplification, adapting), Generation of new information (retrieve information relevant to convo), Text generation (coherent response), Synthesis (converting text to speech)<div class="itemize"><ul><li> <u>The Process</u>: ASR $\rightarrow$ Language Understanding $\rightarrow$ Dialog Manager $\rightarrow$ Language Generation $\rightarrow$ Synthesis<li> <u>Dialog Manager</u>: State of dialog (who is talking), Direction of dialog (what next), References (user profile, etc.), Interaction of database/internet (generative ability) $\implies$ Language generation then turns those structures to words. The DM also has to stall the user while querying for database information, and deal with barge-in! Some decisions include: When to ask open/directive questions? When to confirm? When to barge-in/wait? Which type of feedback to provide (intelligent tutoring system)?<li> <u>Parsing vs LM</u>: [1] Language Models are to generate and understand human language. They predict likelihood of sequence of words (modeling what is naturally said/written) [2] Parsing is analyzing an input sequence to understand grammatical structure and extract meaningful info [3] Models can be *shared*, utilized fro both generating and parsing text [4] Parsing is usually reliant on predefined set of grammar rules, so it doesn't do well with OOG sentences. As a result, only relying on grammatical rules while parsing can be bad and very limiting!<li> <u>SLUs</u>: Spoken Language Understanding involves systems that learn from user interaction. [1] Non-Expert involvement, since regular interactions with human users can provide more training examples (more diverse set of inputs) [2] Active Learning, system can ask users from clarifications/confirmation when it's unsure, which can help reduce the need for large labeled dataset upfront<li> <u>Frame Based Dialog Manager</u>: Used for transaction dialog, Central DS is a frame with slots, and the DM is trying to fill in slots. Allows mixed initiative (where both interactants can lead the convo), Allows over-answering (users can provide more info that currently ask, date AND destination of travel ex.)<div class="itemize"><ul><li> <u>Problems</u>: Not applicable to complex tasks (not a single frame, dynamic construction of info, user access to product)<li> <u>Agenda</u>: Dialog system is organized into hierarchy of frames. Agenda is maintained to determine what needs to be addressed in convo. Handlers are functions used to manage each topic or perform specific actions.</ul></div><li> <u>Statistical Approach to DM</u> (no scripting): [1] Statistical approaches allow DM to handle variations in human convos [2] Optimal Decision making, find optimal path in complex dialog scenarios [3] Life-long learning, allow system to learn from interactions over time, adapting to new patterns in dialogue<li> <u>Policy Search:</u> a dialogue policy dictates how the system should respond in various situations based on the current state of the dialogue. Policy space is often HUGE!<div class="itemize"><ul><li> <u>Problems</u>: [1] Number of policies grows exponentially with the complexity of dialogue system. [2] Insufficient data to train or evaluating every possible policy, so gathering large datasets are challenging</ul></div><li> <u>DM as Markov Decision</u>: Dialog is viewed as a sequence of states in a state space. Policy is the strategy that dictates system actions, reward determines policy, which is cumulative measure of effectiveness. States are specific points in dialog (info).<div class="itemize"><ul><li> <u>Actions</u>: Actions are moves the system can make. Examples include confirming info, rejecting response, querying database, etc.<li> <u>Transition & Reward function</u>: Transition function estimates probability from one state to another $p(s' | s,a))$, modeled using data from real-time convos. Reward function measures effectiveness or goodness of dialog (PARADISE for eval), assigns small negative reward for non-terminal states which encourages efficiency.</ul></div><li> <u>Grounding</u>: the process by which the system and the user establish a mutual understanding of the conversation's content. An example is "Right. Where ... Boston, right." Makes the conversation seem more genuine and human-like!<li> <u>Designing Prompts</u>: Constrain your questions, depending on the type of answer that you are looking for. Long Story Reply: "How many I help you?" Exact Reply: "Which bus numbers do you want schedules for?"</ul></div><b>[14] Bias</b>: Word embeddings encode semantic analogies and bias!<div class="itemize"><ul><li> <u>WEAT Test</u>: Two sets of target words ([set1] engineer, scientist [set2] nurse, librarian), two sets of attribute words (male, female). This test sees cos similarity between words and determines the classification for attributes.<li> <u>Relevant Results</u>: [1] Women are associated with more home-oriented words, men with career oriented words [2] Words can also be driven by cultural connotation [3] The Double Bind: if women succeed in a male dominated job, they are perceived less likeable and more hostile than similarly performing men<li> <u>Debiasing:</u> Pre-processing (edit data before), post-processing (most popular where you remove after training), in-processing. However, even hard-debiasing does not show much improvement but KNN can determine more bias.<li> <u>Types of Bias</u>: Demographic bias (over/under-represents certain groups), Cultural bias (cultural stereotypes in training data), Linguistic biases (low-resource languages excluded), Temporal Bias (limited time periods), Confirmation bias, Ideological & Political Bias</ul></div><b>Example Problem:</b> 300 (+), 700 (-)

<div style="display: flex; justify-content: center; padding: 20px;">
    <table style="border-collapse: separate; border-spacing: 10px;">
        <tr>
            <td style="border: 1px solid white; padding: 10px;">good</td>
            <td style="border: 1px solid white; padding: 10px;">$900$</td>
            <td style="border: 1px solid white; padding: 10px;">$400$</td>
        </tr>
        <tr>
            <td style="border: 1px solid white; padding: 10px;">bad</td>
            <td style="border: 1px solid white; padding: 10px;">$600$</td>
            <td style="border: 1px solid white; padding: 10px;">$400$</td>
        </tr>
        <tr>
            <td style="border: 1px solid white; padding: 10px;">Total</td>
            <td style="border: 1px solid white; padding: 10px;">$10000$</td>
            <td style="border: 1px solid white; padding: 10px;">$50000$</td>
        </tr>
    </table>
</div>

\begin{align*}P(c = \text{POS}|\text{good}) &= \frac{0.3 \cdot 0.09}{0.3 \cdot 0.09 + 0.7 \cdot 0.008}\\P(c = \text{POS}|\text{good,bad}) &= \frac{0.3 \cdot 0.09 \cdot 0.06}{0.3 \cdot 0.09 \cdot 0.06 + 0.7 \cdot 0.008 \cdot 0.008}\end{align*}<br>\begin{align*}P(c = \text{NEG}|\text{good}) &= 1 - P(c = \text{POS}|\text{good}) \\P(c = \text{NEG}|\text{good,bad}) &= 1 - P(c = \text{POS}|\text{good,bad})\end{align*}