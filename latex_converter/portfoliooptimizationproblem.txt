<div class='section'>A Problem on Optimizing Portfolios</div><div class='subsection'>Problem</div>Imagine you have a list of expected returns for equities $\alpha_i$ and a list of variance/risks associated with thoes equities $r_i$. Now, imagine you have some risk constant $\lambda$, which we can assume is a constant for this problem. Your goal is to write a Python function to optimize the following utility function for balancing your portfolio.$$U(\omega_1, \omega_2, \dots, \omega_n) = \sum_{i=1}^n \alpha_i\omega_i - \frac{\lambda}{2} \sum_{i=1}^n r_i\omega_i^2$$<div class='subsection'>Solution</div>Remember that Lagrange is a process of solving a multi-variate problem where we want to optimize $f(x_1,x_2,\dots,x_n)$ with the following constraints $g(x_1, x_2, \dots, x_n)$.\begin{align*}\nabla f(x_1,x_2, \dots, x_n) + \mu \nabla g(x_1,x_2,\dots,x_n) &= 0\\g(x_1, x_2, \dots, x_n) &= k\end{align*}We can define the functions $f$ and $g$ as follows in context of the problem.\begin{align*}f(x_1, x_2, \dots, x_n) &= \sum_{i=1}^n \alpha_i\omega_i - \frac{\lambda}{2} \sum_{i=1}^n r_i\omega_i^2 \\g(x_1,x_2,\dots, x_n) &= \sum_{i=1}^n \omega_i = 0\end{align*}In this problem, we can set up the following system of equations defined by the Lagrange relationship above for every $i \in \{1,2,\dots,n\}$.$$\alpha_i - \lambda r_iw_i + \mu = 0$$Thus, we can describe this system of equations as the following matrix. Notice how the first $n$ rows of the matrix represent the relationship described above, and the last row of the matrix represents the constraint.$$\underbrace{\begin{bmatrix}\lambda r_1 & 0 & 0 & \cdots & \cdots & \cdots & 0 & 1\\0 & \lambda r_2 & 0 & \cdots & \cdots & \cdots & 0 & 1\\0 & 0 & \lambda r_3 & \cdots & \cdots & \cdots & 0 & 1\\0 & 0 & 0 & \cdots & \cdots & \cdots & 0 & 1 \\\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\0 & 0 & 0 & \cdots & \cdots & \cdots & \lambda r_n & 1 \\1 & 1 & 1 & \cdots & \cdots & \cdots & 1 & 0\end{bmatrix}}_{\text{Matrix } A}\begin{bmatrix}\omega_1 \\\omega_2 \\\omega_3 \\\vdots \\\vdots \\\vdots \\\omega_n \\\mu\end{bmatrix}=\underbrace{\begin{bmatrix}\alpha_1 \\\alpha_2 \\\alpha_3 \\\vdots \\\vdots \\\vdots \\\alpha_n \\0\end{bmatrix}}_{\text{Matrix }b}$$To solve this, we will use a numpy library that is meant for linalg.<div class="center-it"><code class="lstlisting" style="text-decoration: none !important; color: white !important;">import&nbsp;numpy&nbsp;as&nbsp;np<br><br>def&nbsp;maximize_function(alphas,&nbsp;rs,&nbsp;lam):<br>&nbsp;&nbsp;n&nbsp;=&nbsp;len(alphas)<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;#&nbsp;construct&nbsp;Matrix&nbsp;A&nbsp;for&nbsp;all&nbsp;omegas<br>&nbsp;&nbsp;A&nbsp;=&nbsp;np.diag([lam&nbsp;*&nbsp;r&nbsp;for&nbsp;r&nbsp;in&nbsp;rs])&nbsp;&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;#&nbsp;add&nbsp;the&nbsp;row&nbsp;for&nbsp;the&nbsp;constraint&nbsp;(1&nbsp;1&nbsp;1&nbsp;1&nbsp;1&nbsp;...&nbsp;1&nbsp;0)<br>&nbsp;&nbsp;constraint_row&nbsp;=&nbsp;np.ones((1,&nbsp;n))&nbsp;<br>&nbsp;&nbsp;A&nbsp;=&nbsp;np.vstack([A,&nbsp;constraint_row])&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;#&nbsp;add&nbsp;a&nbsp;column&nbsp;for&nbsp;the&nbsp;&quot;mu&quot;&nbsp;term&nbsp;and&nbsp;make&nbsp;sure&nbsp;n+1&nbsp;row&nbsp;has&nbsp;a&nbsp;0<br>&nbsp;&nbsp;last_column&nbsp;=&nbsp;np.ones((n,&nbsp;1))&nbsp;<br>&nbsp;&nbsp;last_column&nbsp;=&nbsp;np.vstack([last_column,&nbsp;[[0]]])&nbsp;&nbsp;<br>&nbsp;&nbsp;A&nbsp;=&nbsp;np.hstack([A,&nbsp;last_column])<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;#&nbsp;now,&nbsp;your&nbsp;matrix&nbsp;A&nbsp;should&nbsp;work<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;#&nbsp;construct&nbsp;matrix&nbsp;b,&nbsp;add&nbsp;the&nbsp;0&nbsp;for&nbsp;n+1&nbsp;row<br>&nbsp;&nbsp;b&nbsp;=&nbsp;np.array(alphas&nbsp;+&nbsp;[0])<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;#&nbsp;this&nbsp;will&nbsp;give&nbsp;you&nbsp;(omegas&nbsp;...&nbsp;mu),&nbsp;but&nbsp;we&nbsp;only&nbsp;care&nbsp;about&nbsp;omegas<br>&nbsp;&nbsp;solution&nbsp;=&nbsp;np.linalg.solve(A,&nbsp;b)<br>&nbsp;&nbsp;return&nbsp;solution[:-1]<br></code></div>